\documentclass{article}
\usepackage[pdftex]{graphicx}
\usepackage[export]{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dutch]{babel}
\usepackage{fullpage}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{epstopdf}
\usepackage{relsize}
\newcommand{\zv}{\blacksquare}
\newcommand{\wv}{\square}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\usepackage{float}
\usepackage[caption = false]{subfig}
\usepackage{graphicx}
\begin{document}

\title{Elliptische Kromme Diffie-Hellman}

\author{R.L. Neuteboom (4006712) S.E.M.P. Franssen()\\
\small Universiteit Utrecht \normalsize}

\date{\today}
\maketitle
\section{Inleiding}
Tegenwoordig is het steeds belangrijker communicatie via het internet te versleutelen. Zelfs als informatie nietszeggend blijkt te zijn kunnen mensen die het onderscheppen veel daaruit opmaken. Voorbeeld hiervan heb ik gezien bij een gastcollege van het vak Databases, hier liet de gastspreker zien dat je op basis van geringe informatie over een persoon, vaak relatief eenvoudig een kleine groep mensen kan construeren die het zou kunnen zijn. Zover ik weet is het ook volledig legaal om die informatie af te tappen als het onversleuteld is.\\
Dit verslag gaat over hoe je het Diffie-Hellman protocol kunt gebruiken om versleutelde communicatie op te zetten. Voor dit protocol is een systeem nodig om in te werken. Het systeem dat we gebruiken zullen we doen met een eindige cyclische multiplicatieve groep, deze cre\"eren we met behulp van een elliptische kromme. Verder willen we het bericht ondertekenen, dit zodat de ontvanger weet dat het van ons komt, het kan namelijk zo zijn dat iemand anders contact probeert te zoeken met de ontvanger en valse berichten stuurt. Om af te sluiten gaan we in op hoe we deze technieken/algoritmen hebben ge\"implementeerd in python.
\section{Diffie-Hellman protocol}
Het Diffie-Hellman protocol is een protocol om een sleutel af te spreken die vervolgens gebruikt kan worden voor versleutelde communicatie. Het protocol berust op het feit dat een bepaalde bewerking, bijvoorbeeld multiplicatie in een bepaalde groep, niet makkelijk om te keren is.\\
Laten we het protocol beschrijven:\\
In de Cryptografie is het standaard dat de bedoeling is dat een bericht van A, Alice, naar B, Bob, gaat zonder dat E, Eve, mee kan luisteren.
\begin{itemize}
\item Alice en Bob bespreken openbaar het systeem dat ze gaan gebruiken om de sleutel van latere communicatie te bepalen, in dit verslag dus een bepaalde elliptische kromme en een punt hierop
\item Alice en Bob bedenken afzonderlijk van elkaar een priv\'{e}sleutel
\item Alice en Bob gebruiken de priv\'{e}sleutel op het punt van de elliptische kromme en sturen het resultaat naar elkaar op
\item Vervolgens gebruiken beide hun priv\'{e}sleutel op het ontvangen bericht, Alice en Bob hebben nu een gedeeld geheim die ze kunnen gebruiken voor versleutelde communicatie.
\end{itemize}
Naast elliptische krommen kan ook een ander medium worden gekozen, belangrijk is dat de volgorde van het toepassen van de priv\'{e}sleutels niet relevant is. Het protocol kan ook nog eens worden uitgebreid naar meer personen: elke persoon die je toevoegt moet dan de stappen hierboven doen, er moet dan meerdere malen een ronde komen van punten bewerken met versturen naar de anderen, dit op zo'n manier dat uiteindelijk voor iedereen het punt bekend is dat door alle priv\'{e}sleutels is bewerkt op de zijne na. Het gedeelde geheim is dan uiteraard het beginpunt met alle priv\'{e}sleutels daarop toegepast.\\
We gaan ervan uit dat Eve alle communicatie onderschept en precies weet wat ze aan het doen zijn, het enige van dit verhaal wat zij niet weet zijn de priv\'{e}sleutels en het gedeelde geheim.
Het is voor Eve genoeg om achter \'{e}\'{e}n van de priv\'{e}sleutels te komen, met deze kan ze namelijk achter het gedeelde geheim komen. De veiligheid van het systeem hangt dus af hoe moeilijk het is om gegeven het punt en het punt bewerkt met een van de priv\'{e}sleutels erachter te komen wat de priv\'{e}sleutel is.\\
Omdat we werken in een eindige groep waarbij er voor het omkeren van de bewerking geen algortime is, hangt de moeilijkheidsgraad van het oplossen van dat probleem af van de orde van de groep.

\section{Elliptische Krommen}
Elliptische Krommen kunnen gebruikt worden voor het Diffie-Hellman protocol, voordat we laten zien dat je dat kan gebruiken is het gepast te te bespreken wat elliptische krommen zijn.
Een elliptische kromme is een kromme die beschreven kan worden met punten $(x,y)\in\mathbb{R}^2$ die voldoen aan:
\begin{equation}
y^2 = x^3 + ax +b.
\end{equation}
Voorwaarde hierbij is dat dat de beschreven grafiek niet singulier is, de definitie van singulier hangt af van het type grafiek dat bestudeerd wordt.
Hier komt dat neer op dat de grafiek geen zelf-intersecties, aaneengesloten en we moeten met behulp van een bijectieve parametrisatie $p:\mathbb{R} \to \textbf{E}$ de curve kunnen doorlopen waarbij we overal de afgeleide kunnen bepalen en ongelijk aan nul zijn. Op zo'n grafiek zijn we vooral ge\"interesseerd in punten $(x,y)\in \mathbb{Z}^2$, we moeten daarom ook eisen dat $(a,b)\in\mathbb{Z}$. Reden hiervoor is dat we met de net besproken grafiek een eindige groep maken. We defini\"eren de groep $G$ dan op de volgende manier, een punt op de grafiek met gehele $x$ en $y$ is een element van onze groep. Het eenheidselement, aan te geven met $\infty$ is een punt dat niet op de grafiek ligt, je zou het kunnen zien als het toegevoegde punt voor one-point-compactification. De groepsoperatie '$+$' op punten $A$ en $B$ is op de volgende manier gedefinieerd: \\
je trekt een lijn door $A$ en $B$, laat $C$ het andere snijpunt met de grafiek zijn. Spiegel $C$ in de $x$-as en het resultaat is $A+B$.\\
Hier zitten uiteraard nog haken en ogen aan, hoe gaan we om met optellen met $\infty$ en is er wel altijd precies  \'{e}\'{e}n ander snijpunt? Aangezien we $\infty$ als eenheidselement hebben gedefini\'{e}erd nemen we gewoon het punt waarbij het wordt opgeteld als resultaat. Verder als de je een punt $A$ bij zijn $x$-as spiegeling optelt krijg je geen ander snijpunt, we noemen dan ook zijn $x$-as spiegeling $-A$ en nemen $A + -A=A -A=\infty$. Het enige wat nog laten zien moet worden is dat als je een andere combinatie van punten optelt dat er dus daadwerkelijk een derde snijpunt gevonden kan worden.(CANT REMEMBER SHIT, denk een van die webpagina's)
\subsection{Eindig maken}
Zoals we eerder vermeld hadden willen we een \emph{eindige} groep hebben, dat is de groep hierboven besproken zeerzeker niet of hij bevat alleen $\infty$ wat ook niet nuttig is. De manier waarop we dat doen is de waarden van $x$ en $y$ beperken tot een eindig veld, waarbij alleen gehele getallen zitten. Een eindig veld is een verzameling met daarbij een multiplicatie, additie, subtractie en divisie.\\
Een eindig veld $F$ heeft de volgende eisen:
\begin{itemize}
\item $F$ moet gesloten zijn in de multiplicatie en additie, d.w.z. als je twee elementen van $F$ optelt of vermenigvuldigt is dit weer een element van $F$.
\item er is associativiteit van optelling en vermenigvuldiging: $\forall a,b\in F$ geldt $a +(b + c)= (a + b) + c$ en $(a \cdot b) \cdot c = a \cdot (b \cdot c)$.
\item commutativiteit van optelling en vermenigvuldiging: $\forall a,b\in F$ geldt $a + b= b + a$ en $a \cdot b = b \cdot a$.
\item er zijn eenheidselementen van optelling en vermenigvuldiging: $e_+, e_*$.
\item er zijn additieve en multiplicatieve inversen: $\forall a \in F, \exists a^{-1}_+,a^{-1}_*\in F$ zodanig dat $a + a^{-1}_+=e_+$ en $a \cdot a^{-1}_* = e_*$.
\item distributiviteit van vermenigvuldiging over optelling: $\forall a,b,c \in F$ geldt $a \cdot (b + c) = (a \cdot b) + (a \cdot c)$.
\end{itemize}
Het veld waar wat we gaan gebruiken is $\mathbb{F}_p$ dit is het veld, waarbij de gehele getallen in restklassen modulo $p$ elementen zijn van het veld. Gegeven dat $p$ priem is voldoet $\mathbb{F}_p$ aan de eisen. Wat verder nog op te merken valt is dat we hieruit ook geheeltallige machtsverheffing kunnen gebruiken.

\section{Ondertekenen}
Voor het ondertekenen van de berichten gebruiken we een HMAC (Hash-based Message Authentication Code). Voor HMAC is een cryptografisch veilige hash-functie nodig, hiervoor gebruiken we SHA256. Anders dan bij gebruikelijke hashfuncties zijn deze gemaakt op zo'n manier dat het erg moeilijk is om twee inputs te vinden die dezelfde output geven, daarnaast moet de input niet te achterhalen zijn. De input die wij gebruiken is de versleutelde tekst. 
\section{Implementatie: chat applicatie}
Om een chat applicatie te maken hebben we het volgende gedaan:
We hebben een onversleutelde chatapplicatie (server en client) gekopieerd van het internet om later aan te passen, een paar klassen geschreven om met de elliptische krommen om te gaan en als laatse  een klasse om te versleutelen en ontsleutelen van de tekst met AES geschreven.\\
ruw bestandenoverzicht:\\
\begin{itemize}
\item AES.py de inhoud van dit bestand wordt gebruikt voor AES encryptie en decryptie.
\item EC.py wordt gebruikt om te defini\"eren wat een punt, curve en finite field is.
\item crypto.py is verantwoordelijk voor het toepassen van AES op de tekst en het afspreken van de keys met Diffie-Hellman.
\item tcp.py is het serverprogramma, deze gebruikt bovenstaande bestanden om een connectie op te zetten en communiceert alles van de aangesloten clients door, dit doet hij door met elk van de clients Diffie-Hellman protocol af te gaan.
\item telnet.py is de client, deze moet communiceren met de server, weergeven wat er binnenkomt en ook weergeven wat je hebt getypt.
\end{itemize}
\subsection{diepere werking}
hieronder een overzicht van de klassen, bestanden en de relaties ertussen, een gerichte pijl betekent dat waar de pijl naar wijst gebruikt wordt door waar hij vandaan komt.\\
PLAATJE skype\\

\subsubsection{EC.py}
Dit bestand bevat alles wat nodig is om met de elliptische krommen te kunnen werken. De klasse FiniteFieldElem is ervoor om te zorgen dat er in het eindige lichaam gewerkt kan worden i.c.m. de elliptische kromme, heeft de variabele $p$ om $\mathbb{F}_p$ te kunnen vormen.\\ De klasse Curve heeft twee variabelen $a$ en $b$ zoals eerder om de kromme te defini\"{e}ren en $p$ om aan te geven op welk finitefield we werken.\\
De klasse Punt stelt een punt op een kromme voor, de variabelen x en y zijn FiniteFieldElem's, de klasse Eenheid is een subklasse van Punt en stelt het eenheidselement voor.
\subsubsection{AES.py}
Dit bestand zorgt ervoor dat tekst versleuteld kan worden d.m.v. AES.
\subsubsection{Crypto.py}
Dit bestand bevat de klasse LSEC, wat defini\"eert op welke kromme en eindig lichaam we werken  en de klasse crypto.
De klasse crypto gebruikt zowel AES.py als EC.py, de laatste hiervan om een sleutel af te spreken. AES om de versleuteling van de berichten te doen.
\subsubsection{tcp.py}
dit is de server, hij gebruikt crypto om de berichten te versleutelen en met de clients keys af te spreken.
\subsubsection{telnet.py}
dit is de client, zelfde als tcp maar dan om met de server een key af te spreken.


\section{Conclusie}

\end{document}
