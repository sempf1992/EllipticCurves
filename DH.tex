\documentclass{article}
\usepackage[pdftex]{graphicx}
\usepackage[export]{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dutch]{babel}
\usepackage{fullpage}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{epstopdf}
\usepackage{relsize}
\newcommand{\zv}{\blacksquare}
\newcommand{\wv}{\square}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\usepackage{float}
\usepackage[caption = false]{subfig}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{matrix}

\begin{document}

\title{Elliptische Kromme Diffie-Hellman}

\author{R.L. Neuteboom (4006712) S.E.M.P. Franssen(4035844)\\
\small Universiteit Utrecht \normalsize}

\date{\today}
\maketitle
\section{Inleiding}
Tegenwoordig is het steeds belangrijker om communicatie die via het internet wordt verspreid te versleutelen. Zelfs als informatie nietszeggend lijkt te zijn, kunnen mensen die de gegevens onderscheppen veel daaruit opmaken. Een voorbeeld hiervan heb ik gezien bij een gastcollege van het vak Databases. Hier liet de gastspreker zien dat je op basis van geringe informatie over \'e\'en persoon, vaak relatief eenvoudig uit een grote database een kleine groep kan aanwijzen waar die persoon zich in bevindt. Zolang er geen technische ingreep nodig is om bij de gegevens te komen, kun je in Nederland nog veel verkeer legaal afluisteren.(Pas deze regel aan naar hoe het wel klopt)\\
In dit verslag wordt beschreven hoe je het Diffie-Hellman protocol kunt gebruiken om versleutelde communicatie op te zetten. Voor dit protocol is een systeem nodig om in te werken. Het systeem dat we gebruiken, zal bestaan uit een eindige cyclische multiplicatieve groep. We cre\"eren deze met behulp van een elliptische kromme. Verder willen we het bericht ondertekenen, dit zodat de ontvanger weet dat het van ons komt. Het kan namelijk zo zijn dat iemand anders contact probeert te zoeken met de ontvanger en valse berichten stuurt. Ten slotte gaan we in op hoe we deze technieken/algoritmen hebben ge\"implementeerd in Python.
\section{Diffie-Hellman protocol}
Het Diffie-Hellman protocol is een manier om een sleutel af te spreken die vervolgens gebruikt kan worden voor versleutelde communicatie. De effectiviteit van het protocol is gebaseerd op het feit dat een bepaalde bewerking niet makkelijk om te keren is, bijvoorbeeld multiplicatie in een bepaalde groep.\\
De bedoeling is dat een bericht van A naar B gestuurd kan worden, zonder dat anderen, E, die het bericht onderscheppen het kunnen begrijpen. Dit is het principe van Cyptografie. Binnen de Cryptografie is het standaard  dat A met Alice, B met Bob en de afluisteraar met Eve wordt aangeduid. Als ergens in de tekst het woord \emph{openbaar} wordt gebruikt, komt dat neer op dat ervan uit moet worden gegaan dat derden ook die informatie ontvangen en kunnen lezen.
Het Difie-Hellman protocol gaat als volgt te werk:
\begin{itemize}
\item Alice en Bob communiceren in het openbaar, dus afluisterbaar, het systeem dat ze gaan gebruiken om de sleutel van latere communicatie te bepalen. In ons verhaal is dit door middel van Elliptische Krommen. Hierbij leggen Alice en Bob een kromme, een basispunt op die kromme vast en een priemgetal af.
\item Alice en Bob bedenken afzonderlijk van elkaar een priv\'{e}sleutel.
\item Alice en Bob vermenigvuldigen hun priv\'{e}sleutel met het punt van de elliptische kromme en sturen het resultaat naar elkaar op.
\item Vervolgens vermenigvuldigen beiden hun priv\'{e}sleutel met het ontvangen punt. Alice en Bob hebben nu een gedeeld geheim (dat punt maal beide priv\'esleutels) die ze kunnen gebruiken voor versleutelde communicatie.
\end{itemize}
Naast elliptische krommen kan ook iets anders worden  gekozen. Zolang het iets is waarop je een bewerking kan doen die moeilijk om te keren is en dat het een associatieve commutatieve bewerking is.\\
Het protocol kan ook nog eens worden uitgebreid naar meer personen. Dit uitgebreide protocol werkt als volgt: elk van de personen kiest een priv\'esleutel. 
Het geheim wordt het basispunt maal \emph{alle} priv\'esleutels. Vervolgens wordt er heen en weer gecommuniceerd en krijgt ieder het basispunt maal alle priv\'esleutels, uitgezonderd de zijne te weten. Op deze manier is het nog steeds zo dat afluisteraars alleen maar weten wat het punt maal een aantal, maar niet alle, priv\'esleutels is.  
We gaan ervan uit dat Eve alle communicatie onderschept en precies weet wat we aan het doen zijn. Het enige van dit verhaal wat zij niet weet zijn de priv\'{e}sleutels en het gedeelde geheim.
Het is voor Eve genoeg om achter \'{e}\'{e}n van de priv\'{e}sleutels te komen, met deze kan ze namelijk achter het gedeelde geheim komen. De veiligheid van het systeem hangt dus af hoe moeilijk het is om gegeven het punt en het punt bewerkt met een van de priv\'{e}sleutels erachter te komen wat de priv\'{e}sleutel is.\\
Bij Diffie Helman zijn er twee aanvallen mogelijk. Ten eerste is gegeven $ag$ en $bg$ bepaal $(ab)g$. Dit kan op twee manieren. Ten eerste om direcht uit $ag$ en $bg$ $(ab) g$ uit te rekenen. Hiervoor zijn geen goede methoden bekent. De tweede optie is om uit $ag$ of $bg$ $a$ of $b$ uit te rekenen. Dit komt neer op het discrete logarithme op lossen. Er wordt gedacht dat het discrete logarithme een semi moeilijk probleem is. Het vermoeden is namelijk dat er geen algorithme dat in polynomiale tijd in de lengte van $ag$ het getal $a$ kan bepalen. Er zijn wel subexponentiele algorithmen bekend die $a$ uit $ag$ bepalen en die hebben een looptijd in $ag$. Omdat $ag$ technisch gezien niet een natuurlijk getal is, maar kwa orde van grootte in de buurt ligt van de orde van de groep van de elliptische kromme zijn de best bekende algorithmen baby step giant step en pollards rho, algorithmen die in $O( \sqrt{N})$ werken waarbij $N$ de orde van de elliptische groep is. Omdat $N$ exponentieel groeit met de lengte van $N$ is dit dus een subexponentieel algorithme. Het vermoeden dat er geen sneller algorithme bestaat om het discrete logarithme op te lossen is zo sterk dat dit als bewijs van veiligheid wordt gezien.

\section{Elliptische Krommen}
Het Diffie-Hellman protocol kan gebruik maken van Elliptische Krommen. Voor we bespreken hoe dat kan, stellen we vast wat Elliptische Krommen zijn. \\
Een elliptische kromme is een kromme die beschreven kan worden met punten $(x,y)\in\mathbb{R}^2$ die voldoen aan:
\begin{equation}
y^2 = x^3 + ax +b.
\end{equation}
Om een bruikbare Elliptische Kromme te hebben moeten we de voorwaarde stellen dat zijn grafiek non-singulier is. De definitie van singulier hangt af van het type grafiek wat bestudeerd wordt. Voor dit type grafiek betekent singulier dat de grafiek voldoet aan de volgende eisen:
\begin{itemize}
\item De grafiek heeft geen zelfintersecties.
\item De punten van de grafiek: $E$ moet beschreven kunnen worden met een bijectieve parametrisatie, oftwel $\exists p \in C(\mathbb{R},E)$ bijectief.
\item De parametrisatie moet de afgeleide overal gedefinieerd zijn en ongelijk aan nul. 
\end{itemize}
Op de grafiek van een elliptische kromme zijn we ge\"interesseerd in punten $(x,y)\in \mathbb{Z}^2$. Om te zorgen dat de kromme daar ook punten in heeft, eisen we dat $(a,b)\in\mathbb{Z}$. Reden hiervoor is dat we met de net besproken grafiek een eindige groep maken. We defini\"eren de groep $G$ dan op de volgende manier, een punt op de grafiek met gehele $x$ en $y$ is een element van onze groep. Het eenheidselement, aan te geven met $\infty$, is echter een punt dat niet op de grafiek ligt. Je zou het punt $\infty$ kunnen zien als het toegevoegde punt voor one-point-compactification.(Dat klopt toch?) De groepsoperatie '$+$' op punten $A$ en $B$ is op de volgende manier gedefinieerd: \\
we trekken een lijn door $A$ en $B$, laat $C$ het andere snijpunt met de grafiek zijn. We spiegelen $C$ in de $x$-as en het resultaat is $A+B$. Zie ook figuur \ref{optellen}.\\
\begin{figure}[H]
\center
\iffalse
\includegraphics[scale=0.3]{add-points-example.png}
\else
\includegraphics[scale=0.3]{imgo.jpeg}
\fi
\caption{Optelling van punten op Elliptische Krommen, bron jeremykunblabla.}\label{optellen}
\end{figure}
Er zijn hierbij een aantal zaken nog onbesproken. Een punt bij zichzelf optellen is niet goed gedefinieerd met de definitie van daarnet. We defini\"eren de lijn met de raaklijn en dan werkt het wel. Dat die raaklijn een snijpunt heeft met de curve zou aangetoond kunnen worden met de stelling van B\'ezout (BRON jeremykunblablabl).\\
De stelling van B\'ezout gaat over het aantal gemeenschappelijke punten van twee algebra\"ische krommen. De stelling komt uit de algebra\"ische meetkunde. Wij zijn echter te weinig bekend met dit wiskundig gebied om deze stelling en het bijbehorende bewijs in dit verslag te kunnen verwerken. \\
Als we een punt bij zijn x-as spiegeling optellen is er geen derde punt op de kromme. We defini\"eren dat in de x-as spiegelen neer komt op vermenigvuldigen met $-1$ en uit de optelling met zijn inverse komt dan ook $\infty$. \\
Iets wat in het vorige hoofdstuk vermeld is maar nog niet aangetoond wordt, is dat de optelling associatief en commutatief moet zijn. Dat de optelling van punten op de elliptische kromme commutatief is, kunnen we direct uit de definitie halen van de optelling. Om te laten zien dat de optelling associatief is, moet ook de stelling van B\'ezout gebruikt worden. Om die reden moeten wij helaas ook dit bewijs achterwege laten.
\subsection{Eindige velden}
Zoals we eerder vermeld hebben, willen we een \emph{eindige} groep hebben. De hierboven besproken groep is dat niet of hij bevat alleen $\infty$, wat ook niet nuttig is. De manier waarop we dat doen is de waarden van $x$ en $y$ beperken tot een eindig lichaam, waarin alleen gehele getallen zitten. Een lichaam is een verzameling met daarbij een multiplicatie, additie, subtractie en divisie.\\
Een eindig lichaam $F$ voldoet de volgende eisen:
\begin{itemize}
\item Op $F$ bestaat een bineare operator $+$ die $F$ in een abelse groep maakt. Dat wil zeggen, dat $F$ gesloten is onder $+$, en dat $+$ associatief en commutatief is. Verder bestaat er een eenheidselement $0$ en voor elk element $a \in F$ bestaat er een $-a$ zodat $ a + -a = 0$.
\item Op $F$ bestaat er een bineare operator $\cdot$ zodat $F-\{0\}$ een groep is.
\item distributiviteit van vermenigvuldiging over optelling: $\forall a,b,c \in F$ geldt $a \cdot (b + c) = (a \cdot b) + (a \cdot c)$ en $(a+b)\cdot c = (a \cdot c) + (b \cdot c)$.
\end{itemize}
Het lichaam dat wat we gaan gebruiken is $\mathbb{F}_p$, ook wel $\mathbb{Z}/p$. Ofwel de gehele getallen modulo $p$. Gegeven dat $p$ priem is voldoet $\mathbb{F}_p$ aan de eisen. Wat verder nog op te merken valt is dat we hierop ook geheeltallige machtsverheffing kunnen uitvoeren. Er bestaat op isomorpisme na een eindig lichaam van cardinaliteit $p^n$ voor $p$ priem en $n \in \mathbb{N}$. Verder bestaan er geen eindige groepen. Het bewijs hiervan wordt geleverd in bijvoorbeeld het diktaat van beukers bij Ringen en Galois.
\subsection{Samenvoegen Elliptische Kromme met eindig veld}
De manier waarop we deze begrippen samenvoegen is door de groep van de Elliptische Krommen te gebruiken met \'e\'en verschil: $x$ en $y$ worden met hun respresentant (kleinste positieve waarde) uit de equivalentieklasse uitgedrukt. Het lijkt misschien gek dat dit kan, maar als we formules hebben die de rol overnemen van de lijnen trekken, maakt het daarbij niet uit of we in een eindig lichaam of in de gehele getallen werken.\\
Dan moeten we uiteraard wel formules hebben.
Laten we eerst proberen een formule te construeren, die ervoor zorgt dat we twee verschillende punten bij elkaar op kunnen tellen.
Stel we tellen $(x_A,y_A)$ bij $(x_B,y_B)$ op, met als $x_A=x_B$ dan $y_B\neq -y_A,y_A$. We lopen het algoritme af en vinden een formule voor de lijn die we zouden trekken:
\begin{equation}
L(x) = \frac{y_A - y_B}{x_A - x_B} (x - x_B) + y_B 
\end{equation}
Om aan het andere snijpunt te komen, hoeven we alleen maar de andere wortel van de volgende vergelijking te vinden:
\begin{equation}
(L(x))^2 = x^3 + ax + b 
\end{equation}
Omdat we de twee andere wortels al hebben, kunnen we dit gemakkelijk oplossen met Vieta's formule(BRON).
Volgens die formule geldt het volgende:\\
Als je een polynoom van de vorm $$\sum_{k=0}^n a_kx^k$$ hebt, geldt als $\{x_1,x_2,...,x_n\}$ de wortels van die polynoom zijn (inclusief dubbele): $$\sum_{k=1}^n x_n =-\frac{a_{n-1}}{a_n}.$$
Ofwel bij deze formule hoeven we alleen nog maar de co\"efficient van $x^2$ te vinden. Als we dit uitwerken hebben we $$a_2 = (\frac{y_A - y_B}{x_A - x_B})^2$$ dus $$x_C = (\frac{y_A - y_B}{x_A - x_B})^2 - x_A - x_B.$$ De bijbehorende $y_C$ krijgen we door hem in te vullen: $$y_C= \frac{y_A - y_B}{x_A - x_B} (x_C - x_B) + y_B.$$
Laten we nu het snijpunt gaan vinden als we een punt bij zichzelf optellen.
Eerst moeten we de helling van de elliptische kromme in ons punt vinden. Dit kunnen we voor elkaar krijgen door impliciete differentiatie:\\
we nemen de afgeleide naar $x$ aan beide kanten van onze vergelijking van de elliptische kromme.
\begin{equation}
\frac{\partial}{\partial x}(y^2) = \frac{\partial}{\partial x}(x^3 + ax + b).
\end{equation}
Dit is hetzelfde als:
\begin{equation}
\frac{\partial y^2}{\partial y} \cdot \frac{\partial y}{\partial x} = 2y \cdot \frac{\partial y}{\partial x}=3x^2 +a.
\end{equation}
Nu hebben we dat:
\begin{equation}
\frac{\partial y}{\partial x} = \frac{3x^2 +a}{2y}.
\end{equation}
Resultaat is dat we nu de vergelijking voor de beschreven lijn hebben, gegeven we het punt $(x_A,y_A)$ bij zichzelf optellen hebben we:
$$L(x) = \frac{3x^2 +a}{2y}(x - x_A) + y_A.$$
Met hetzelfde proces, dus ook het toepassen van Vieta's formule krijgen we:
$$x_B = (\frac{3x^2 +a}{2y}(x - x_A))^2 - 2x_A \textit{ en } y_B  = \frac{3x^2 +a}{2y}(x_B - x_A) + y_A.$$
Nu hebben we dus alles wat nodig is om zonder de lijnen te trekken het laatste snijpunt te vinden. Wat niet vergeten moet worden, is dat om de optelling te voltooien dit punt nog gespiegeld moet worden in de $x$-as, ofwel als het laatste snijpunt $(x_R,y_R)$ is, hebben we als resultaat van de optelling $(-x_R,y_R)$.

\section{Versleuten}
Als Alice en Bob berichten naar elkaar willen sturen moet er meer gebeuren dan alleen een sleutel af spreken, we moeten deze sleutel ook gebruiken om het bericht te versleutelen. \\Het basis algorithme dat we gebruiken is AES, de advanced encryption standard. Dit is de opvolger van DES, de data encryption standaard. Het is een blok cijfer, dat wil zeggen dat je hem een blok data van een bepaalde lengte, in het geval van AES 16 bytes, geeft, en een sleutel, en dan versleuteld het algorithme de data aan de hand van de sleutel. 
\\Een cryptografisch versleutelingsalgorithme (cijfer)  moet voor een gegeven sleutel bijectief zijn. Voor elke invoer moet er uitvoer zijn, en deze moet ook weer terug gezet kunnen worden naar de oorspronkelijke tekst. 

\subsection{Analyse van de veiligheid van AES}
Omdat we AES gebruiken is een analyse van de veiligheid van AES van belang. We noemen een aanval op AES succesvol als het een snellere aanval is dan brute kracht alle sleutels af lopen. We bekijken eerst hoe lang het duurd om AES op brute kracht te kraken. Daarna gaan we kijken naar verfijndere methodes om AES te kraken. De twee meest gangbare methodes om blok algorithmes te kraken zijn differential analyses en Linear analysis. Deze worden dadelijk in meer detail behandeld. AES zal veilig tegen deze aanvallen blijken te zijn. Verder noemen we nog een aantal succesvolle aanvallen onder extra voorwaarden. Deze kraken AES net, maar hebben geen praktisch nut omdat ze alsnog te moeilijk zijn om praktisch te implementeren. De kansen die bij Linear en Differential cryptoanalyse worden genoemd komen uit de paper van de ontwerpers van AES. Deze staan in de vijfde bron.
\subsubsection{Brute Force}
AES gebruikt een key van 16 bytes. Dit betekend dat er $2^{128}$ mogelijke keys zijn. Dit is op dit moment te veel om met een computer langs te lopen, een computer die 100 miljard sleutels per seconde probeerd ( buiten berijk van een enkele personal computer) kost het kraken van een enkel bericht $10^20$ jaar. Nemen we voor elke persoon op aarde 2 computers kost het alsnog $7,7 \times 10^9$ jaar. Dit is net wat korter dan de huidige leeftijd van het heelal, deze is namelijk ongeveer $1,3 \times 10^10$ jaar. Omdat we gemiddeld na de helft van de sleutels proberen de juiste sleutel hebben gevonden, zouden we met de huidige hypothetische stand van zaken 4 AES berichten kunnen kraken in de leeftijd van het heelal. Dus op brute kracht de sleutels af lopen is ondoenlijk.
\subsubsection{Differential Cryptoanalyse}
Verder is AES ook goed beschermd tegen andere bekende families van aanvallen die tegen blok cijfers worden ingezet. Zo is AES bewijsbaar immuun voor differential analysis. Het idee van differential analysis is als volgt. Stel we hebben een bericht $B$. We kiezen nu een bepaald verschil en zorgen dat we nog een bericht krijgen $B'$ dat precies dit verschil heeft. Als we nu kijken naar de uitkomst van de versleutelingen zou er tussen deze berichten geen vast verschil mogen zitten. Dit mag ook niet gebeuren met een vaste kans. Het bewijs dat AES immuun is voor dit soort aanvallen gaat als volgt. AES maakt intern gebruik van 10 rondes van versleutelingen. De makers van AES hebben in kaart gebracht hoe verschillen tussen twee invoeren door $4$ rondens heen gaan. De kans dat als er een verschil is na vier rondes bij invoer van twee blokken invoer met een vast verschil is van boven begrensd door $2^{-150}$. Deze kans wordt alleen maar kleiner op het moment dat er meer rondes zijn. Zo zijn er naar 8 rondes nog maar $2^{-300}$ kans op propogatie van zo'n verschil. Het is voldoende om immuun te zijn tegen differential cryptoanalyse om een propogatie kans te hebben van $2^{1-n}$ waar $n$ de blok lengte in bits is. Aan deze eis is dus voldaan en is AES bewijsbaar veilig tegen differential cryptoanalyse. Dit is de meest toegepaste vorm van cryptoanalyse tegen moderne blokcijfers.

\subsubsection{Linear Cryptoanalyse}
Een ander veel gebruikte vorm van aanvallen tegen blok cijfers is een verwante eigenschap. In plaats van kijken naar hoe verschillen tussen twee invoerblokken zich verspreiden door het algorithme kun je ook kijken naar hoe lineaire combinaties van bits in de invoer verbant houden met bits in de uitvoer. Dit is als het ware het algorithme lineariseren. Linear cryptoganalyse is ook onmogelijk tegen AES want we zijn geinterreseerd in de outliers. De kans op een willekeurig verband tussen bits in de invoer en uitvoer is $0.5$ met standaard deviatie $2^{-n/2}$. Dus de systematische uitschieters moeten kleiner zijn dan dit getal om niet op te vallen. Voor vier rondes van AES is bewezen dat de beste combinatie na vier rondes een kans heeft van maximaal $2^{-75}$ van $0.5$ af. Als we nu aannemen dat we daarna weer na vier rondes weer de optimale route kunnen volgen is de afwijking in de kans dus $2^{-150}$, en dus is AES met 10 rondes veilig tegen linear cryptoanalyse.
\subsubsection{Succesvolle aanvallen op AES}
Er zijn wel succesvolle aanvallen tegen AES geweest. Deze zijn gebaseerd op het relatief zwakke algorithme dat AES gebruikt om een sleutel uit te breiden. Als je verwante sleutels hebt kun je zo misbruik maken van relaties tussen de sleutels en de ronde sleutels om zo AES in kortere tijd te kraken voor versies met sleutel grootte 196 bits en 256 bits. Deze aanvallen verlagen de sterkte van AES tot respectiefelijk ongeveer 176 bits en 99.5 bits. Verder is er een voortzetting op differential cryptoanalyse, de bicycle aanval. Deze werkt door zowel van voren als van achteren te werken, en ergens in het midden te ontmoeten. Door structuur in het algorithme te misbruiken kun je zo in ongeveer werklast van $2^126.1$ encrypties AES kraken. Dit is de huidige beste aanval die publiekelijk bekend is op AES.

\subsection{AES op langere blokken tekst dan 128 bits}
We willen AES ook kunnen gebruiken om stukken tekst te versturen die langer zijn dan 128 bits. We merken ten eerste op dat als de lengte van het bericht geen veelvoud van 16 bytes is, deze moet worden verlengd naar 16 bytes. Echter, nu kunnen we geen verschil zien tussen een bericht dat toevallig op dezelfde manier eindigde op hoe we ons bericht zouden verlengen. Daarom als ons bericht een veelvoud is van 16 bytes voegen we nog een heel extra blok toe.
\\Dit zorgt dat we AES op alle blokken kunnen toepassen. Helaas is er nu nog een probleem. Als twee blokken dezelfde invoer hebben, geven ze dezelfde uitvoer want het algorithme moet inverteerbaar zijn. Dit geeft een aanvaller waardevolle informatie, want nu kent hij relaties tussen de klare teksten die verstuurd zijn. Om dit te voorkomen worden er bepaalde vormen van chaining gebruikt. Wij gebruiken codeblockchaining. Dit houdt in dat we voordat we een blok data versleutelen, we hem eerst via een xor bewerking met de uitkomst van het vorige blok veranderen. Deze bewerking is inverteerbaar want de xor operatie is zelf inverse ( A xor B xor B = A). Het heeft als voordeel dat de aanvaller nu niet weet wanneer twee stukken klare tekst hetzelfde waren. Misschien is het probleem al opgevallen van het eerste blok, waar wordt deze mee gexored. Je zou natuurlijk niets kunnen doen. Helaas blijkt dat dit niet veilig is. Daarom genereren we een initialisatie vector. Deze gedraagt zich als de uitvoer van de versleuteling van het vorige blok. Als een bericht versleuteld is nemen we als nieuw IV de versleuteling van het laatste blok. Dan kan de versleuteling gezien worden als een lange stroom aan data die versleuteld wordt.

\subsection{Aanvallen op codeblockchaining}
Als we een bericht niet ondertekenen kunnen we het verstuurde bericht onderscheppen en het voorlaatste blok aanpassen. Het idee is als volgt. We passen de laatste byte aan van het voorlaatste blok. We laten deze laatste byte alle 256 mogelijke waarden doorlopen. Als we nu het bericht laten ontsleutelen zal hij een aantal keer worden afgekeurd, omdat het algorithme herkent dat de methode van verlenging niet geldig is. Maar hij zal ook een aantal keer worden goed gekeurd. Een daarvan is het geval dat de lengte van de verlenging herkend wordt als precies 1 byte. De andere keer dat hij geaccepteerd wordt is als de verlenging herkent wordt als de echte verlenging van het blok, namelijk dat we het bericht niet veranderd hebben. Indien deze twee hetzelfde zijn is er maar een bericht geaccepteerd en de rest geweigerd. Wat we nu gaan doen is de volgende byte van het blok kraken. We weten wat we moeten doen om de verlenging aan te passen zodat het algorithme denkt dat hij met twee bytes is verlengd. Omdat we nu de tweede byte aanvallen hoeven we weer 256 bytes te proberen tot we weer raak hebben. Dit geeft ons de tweede byte van de klare tekst. Dit kunnen we doen tot we het hele blok hebben ontcijfert.
\\Als we nu verder willen, halen we gewoon het hele blok eraf. We kunnen nu hetzelfde spelletje doen totdat we dit hele blok hebben ontcijferd. En dit kunnen we doen voor alle blokken data die versleuteld zijn. Hiermee kun je dus een hele cijfertekst boven water halen in $256 n$ stappen voor een tekst van $n$ bytes. Merk op dat we geen gebruik hebben gemaakt van de eigenschap van het onderliggende blok cijfer, alleen van codebookchaining en de eigenschappen van de verlenging van de klare tekst. En het feit dat we geen methode hebben om de authenticiteit van een bericht te controlleren. Om dit te controlleren gaan we een bericht op een veilige methode ondertekenen.

\section{Ondertekenen}
Voor het ondertekenen van de berichten gebruiken we een HMAC (Hash-based Message Authentication Code). Voor HMAC is een cryptografisch veilige hash-functie nodig, hiervoor gebruiken we SHA256. Anders dan bij gebruikelijke hashfuncties zijn deze gemaakt op zo'n manier dat het erg moeilijk is om twee inputs te vinden die dezelfde output geven, daarnaast moet de input niet te achterhalen zijn. De input die wij gebruiken is de versleutelde tekst. De veiligheid van een MAC meten we in hoe gemakkelijk het is om een verandering in het bericht in te brengen en een daarbij behorende MAC te geven. Een bovengrends van de veiligheid wordt gegeven door hoe gemakkelijk het is om een preimage van een bericht te vinden gegeven een hashwaarde. Deze kunnen we namelijk dan door laten gaan voor het oorspronkelijke bericht. Echter kan het ook zijn dat er op een andere methode een ondertekening wordt vervalst. Op dit moment zijn er geen praktische aanvallen tegen HMAC sha256 publiekelijk bekend. Dit wil zeggen dat er zover bekend geen berichten kunnen worden vervalst zonder dat deze vervalsing wordt opgemerkt. Deze eigenschap zal later van belang zijn als we gaan bewijzen dat onze versleutel en onderteken methode veilig is.

\section{Veiligheid van encrypt then sign}
We gaan nu de veiligheid analyseren van encrypt then sign. We gaan er voor de analyse ervan uit de zowel AES als HMAC perfecte algorithmen zijn. Dit vergemakkelijkt de analyse, maar voor de praktische correctheid maakt het niet uit, omdat AES en HMAC op dit moment niet praktisch te kraken zijn. We geven alleen een bewijsschets omdat de technische analyse erg lang is. 
\\Het idee is als volgt: we gaan laten zien dat onze versleutelingsmethode veilig is tegen de meest krachtige aanvaller die er is. We sturen de aanvaller een klare tekst toe, en een tekst die de zogenaamd de versleuteling van deze tekst is. Met kans $0.5$ is het de echte versleuteling van deze tekst, en met kans $0.5$ is het een willekeurig bericht. Nu mag de aanvaller $N$ acties ondernemen. Een actie is het ontsleutelen van een ander bericht dan de ontvangen cijfertekst of het versleutelen van een bericht dat niet de klare tekst is. De aanvaller wint het spel als hij een algorithme kan vinden dat wint met kans meer dan $0.5 + \epsilon$, waarbij het aantal acties $N$ een polynomiale functie van $\epsilon$ is. Dit geeft aan dat voor een hele kleine kans er minder acties mogelijk zijn. Ook moet $\epsilon$ groter zijn dan $0$, want anders is dit triviaal waar, kies een van de twee opties, en dan heb je met kans $0.5$ gelijk.
\\Om nu aan te tonen dat dit algorithme veilig is gebruiken we dat AES en HMAC zelf veilig zijn. Dit heeft als gevolg dat er binnen polynomiale tijd geen vervalsingen kunnen worden aangemaakt voor een cijfertekst. Dus we kunnen geen berichten laten ontsleutelen. Deze worden allemaal geweigerd op autenticiteit en we krijgen geen informatie over de mogelijke klare tekst. Omdat we er van uit gaan de AES een perfect algorithme is kunnen we ook vanuit de andere richting geen informatie verzamelen. We mogen geen versleutelingen aanvragen van klare teksten die overeenkomen met de gegeven klare tekst van de uitdaging. En de versleutelingen van de andere teksten zijn onafhankelijk van de versleuteling van de ware tekst. Het enige wat kan gebeuren is dat bij het versleutelen van berichten toevallig de versleuteling van een bericht overeenstemt met de opgegeven versleuteling. De kans hierop is linear in het aantal versleutelde berichten omdat AES een perfect algorithme is. Om dat we een begrenzing op $N$ hebben in $\epsilon$ is de kans dat we op die methode kennis vergaren van het juiste antwoord kleiner dan $\epsilon$. Dus de aanvaller kan geen informatie halen uit onze methode.

\section{Implementatie: chat applicatie}
Om een chat applicatie te maken hebben we het volgende gedaan:
We hebben een onversleutelde chatapplicatie (server en client) gekopieerd van het internet om later aan te passen, een paar klassen geschreven om met de elliptische krommen om te gaan en als laatse  een klasse om te versleutelen en ontsleutelen van de tekst met AES geschreven.\\
ruw bestandenoverzicht:\\
\begin{itemize}
\item AES.py de inhoud van dit bestand wordt gebruikt voor AES encryptie en decryptie.
\item EC.py wordt gebruikt om te defini\"eren wat een punt, curve en finite field is.
\item crypto.py is verantwoordelijk voor het toepassen van AES op de tekst en het afspreken van de keys met Diffie-Hellman.
\item tcp.py is het serverprogramma, deze gebruikt bovenstaande bestanden om een connectie op te zetten en communiceert alles van de aangesloten clients door, dit doet hij door met elk van de clients Diffie-Hellman protocol af te gaan.
\item telnet.py is de client, deze moet communiceren met de server, weergeven wat er binnenkomt en ook weergeven wat je hebt getypt.
\end{itemize}
\subsection{diepere werking}
hieronder een overzicht van de klassen, bestanden en de relaties ertussen, een gerichte pijl betekent dat waar de pijl naar wijst gebruikt wordt door waar hij vandaan komt. Vervolgens gaan we in op hoe de communicatie verloopt tussen server en clients.

\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=2em,minimum width=2em]
  {
   TCP & telnet\\
   crypto \\
   EC & AES\\
   };
  \path[-stealth]

    (m-1-1) edge node [left] { } (m-2-1)
    (m-1-2) edge node [left] { } (m-2-1)
    
    (m-2-1) edge node [right] {} (m-3-1)

    (m-2-1) edge node [left] {} (m-3-2);   
\end{tikzpicture} 
\end{center}
Communicatie verloopt als volgt. Stel we verbinden als Client C met een server S. Als eerste stap zal de server alle andere gebruikers op de hoogte stellen dat er een nieuw iemand meeluistert, ook reageert de server met de eerste stap van het DH protocol op C. De Client stuurt zelf ook de eerste stap van het DH protocol op. Vervolgens berekenen de Server S als de Client C hun gedeeld geheim. Van dit geheim worden deelsleutels gemaakt die de up- en downstream van en naar de server beveiligen. Als C een bericht wil sturen aan de anderen die verbonden zijn met de server versleutelt C zijn bericht met de upstream keys naar de server. Vervolgens verstuurt C dit bericht naar de server. De server ontvangt dit bericht en ontsleutelt deze met de upstream key van C naar de server. Nu heeft de server het bericht dat C aan alle andere clients wilde sturen. Vervolgens genereert de server voor elke client $\tilde{C}$ een eigen versleuteling van het bericht met de downstream sleutels van $\tilde{C}$ naar de server. Vervolgens verstuurt de server dit bericht naar $\tilde{C}$. $\tilde{C}$ ontvangt dan dit bericht en kan met zijn downstream keys dit bericht ontsleutelen. 
\subsubsection{EC.py}
Dit bestand bevat alles wat nodig is om met de elliptische krommen te kunnen werken. De klasse FiniteFieldElem is ervoor om te zorgen dat er in het eindige lichaam gewerkt kan worden i.c.m. de elliptische kromme, heeft de variabele $p$ om $\mathbb{F}_p$ te kunnen vormen voor $p$ priem.\\ De klasse Curve heeft twee variabelen $a$ en $b$ zoals eerder om de kromme te defini\"{e}ren en $p$ om aan te geven op welk finitefield we werken.\\
De klasse Punt stelt een punt op een kromme voor, de variabelen x en y zijn FiniteFieldElem's, de klasse Eenheid is een subklasse van Punt en stelt het eenheidselement voor.
\subsubsection{AES.py}
Dit bestand zorgt ervoor dat tekst versleuteld kan worden d.m.v. AES. Als begin hebben we een implementatie van AES van het internet af geplukt die een blok van 16 bytes versleutelde met behulp van een 16 byte sleutel. Vervolgens hebben we deze code aangepast zodat hij een willekeurig lange stroom data kan versleuten, met behulp van codebookchaining. Deze module moet geinitialiseerd worden met een masterkey en een iv. De masterkey genereerd de rondesleutels, en deze moet elke sessie willekeurig gekozen worden of tot stand komen door een betrouwbaar key agreement protocol, en geheim blijven. De IV hoeft alleen willekeurig te zijn. Bij een gefixeerde IV, of niet willekeurig gekozen IV daald het aantal bericht die veilig versleuteld kunnen worden zonder collisies.
\subsubsection{Crypto.py}
Dit bestand bevat de klasse LSEC, wat defini\"eert op welke kromme en eindig lichaam we werken  en de klasse crypto.
De klasse crypto gebruikt zowel AES.py als EC.py, de laatste hiervan om een sleutel af te spreken. AES om de versleuteling van de berichten te doen. Na de versleuteling worden de berichten ondertekend met een HMAC gebaseerd op SHA256. Er is gekozen voor encrypt then sign omdat deze methode veel minder gevoelig is voor side channel aanvallen, en dezelfde theoretische veiligheid bied. \\Verder wordt in Crypto.py verzorgd dat als er een gemeenschappelijke sleutel is afgesproken er via herhaald hashen via pbkdf2 hmac veilige sleutels en IVs worden verzorgd voor de upstream en downstream van gegevens, de IV voor die streams en de sleutels om die streams te ondertekenen met behulp van HMAC.
\subsubsection{tcp.py}
tcp.py is de Python file met daarin de server code. Deze houdt alle users bij met hun keys, en als er een bericht binnenkomt dan stuurt de server dit bericht door naar alle andere users van de server. De server gebruikt crypto.py om de berichten te versleutelen en met de clients keys af te spreken.
\subsubsection{telnet.py}
De Python file telnet.py is de file  voor de client en zorgt hij verbinding kan leggen met de server en kunnen communiceren. De client heeft in tegen stelling tot de server geen verbinding met alle gebruikers van de server maar alleen met de server zelf. 


\section{Aanvallen op de implementatie}
We bespreken in deze sectie enkele aanvalsmogelijkheden die een aanvaller hebben om het verkeer te onderscheppen. Ten eerste kan iedereen verbinding maken met de server waarop er gecommuniceerd wordt en het gesprek afluisteren. Echter, als iemand verbinding maakt wordt dit bericht naar alle andere gebruikers gepushed en zijn alle gebruikers op de hoogte dat er iemand meeluisterd. Er zijn ook andere methoden waarop de gebruikers niet op de hoogte hoeven zijn dat er iemand mee luistert. Verder kan het protocol gemakkelijk worden aangepast dat mensen zich moeten identificeren via een wachtwoord voordat ze mee mogen luisteren. Dit vergt een paar kleine aanpassingen voor de communicatie zelf. Echter wordt het problematisch om jezelf bij de server te registreren als ongeregistreerde berichten negeert worden. Hier zal een middenweg in gezocht moeten worden.
\subsection{Man in the middle}
Een iemand zou zich kunnen voordoen als een betrouwbare Server door al het verkeer af te luisteren. Vervolgens kan deze persoon dit verkeer door sluizen naar de echte server en tegen de server doen alsof hij de Client is. Omdat ip-pakketten vervalst kunnen worden kan dit worden gedaan zonder dat de gebruikers er iets van merken. 
\subsection{Server omkopen}
Omdat al het verkeer via de server wordt geleid en de server over alle keys beschikt, kan een kwaadwillende server al het verkeer prijsgeven. 
\subsection{Side channel aanvallen}
Onze server is niet beveiligd tegen alle sidechannel aanvallen. Onze DH suite is licht gevoelig voor timing aanvallen en die zou gebruikt kunnen worden om de interne staat van de klasse random te verraden. De klasse random is niet cryptografisch veilig en iemand kan daarmee gegevens over de geheime sleutel van de Client bemachtigen. Deze geven dan de mogelijkheid om de gedeelde sleutel te bemachtigen want met de geheime sleutel en de publieke transactie kan alles worden afgeluisterd.
\\Na de Key-Exchange zijn er geen side channel aanvalmogelijkheden bekend die van een afstand uit te voeren zijn. We gebruiken encrypt-then-sign omdat deze robuuster is tegen side channel aanvallen.

\subsection{Theoretische aanvallen}
Er bestaan ook aanvallen tegen AES en DH. Deze aanvallen zijn puur theoretisch op dit moment en zijn niet praktisch haalbaar. Als het discrete logarithme probleem wordt opgelost zou dit een flinke klap zijn voor de veiligheid van versleutelings algoritmen gebaseerd op Diffie-Hellman sleutel uitwisseling. Echter zijn elliptische krommen resistanter dan andere varianten van het Diffie-Hellman protocol. Verder zou het kunnen dat AES gebroken wordt en er een ciphertext aanval komt. Dit is echter onwaarschijnlijk aangezien AES een goed onderzocht protocol is, gebaseerd op wiskundig goed onderbouwde methoden. Ten derde zou men een aanval tegen bijvoorbeeld SHA256 kunnen vinden zodat de message authenticatie vervalst kan worden en mensen daarna side channel aanvallen tegen gewoon cbc AES gaan doen via adaptive chosen ciphertext. Dit is echter moeilijker omdat de code die we geschreven hebben geen resultaat terug geeft over hoe lang het duurde om alles te ontsleutelen en of de ontsleuteling gelukt is. Dus via deze methode kun je ook geen delen van de data terugvinden.

\section{Conclusie}
We hebben in dit project een applicatie geschreven waarbij men redelijk veilig kan communiceren over het internet. Als een user eenmaal veilig de verbinding tot stand heeft gebracht kan men moeilijk het verkeer af luisteren. De optie om de servereigenaar af te kopen en de geheimen prijs te geven blijft echter altijd bestaan. Een manier om dit te voorkomen is de server en een van de clients op dezelfde computer te draaien en via andere communicatie af te spreken wie de server beheert.

\section{gebruikte bronnen}
http://www.binarytides.com/code-chat-application-server-client-sockets-python/\\
https://github.com/bozhu/AES-Python\\
Weisstein, Eric W. "Field Axioms." From MathWorld--A Wolfram Web Resource.\\ http://mathworld.wolfram.com/FieldAxioms.html \\
http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf\\
en andere eventuele bronnen vermeld in de Python3 bestanden.
\end{document}
